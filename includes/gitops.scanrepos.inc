<?php
/**
 * @file
 * Drush scan git processing classes.
 */

/**
 * The base project class.
 */
class GitopsScanRepos {

  /**
   * TRUE if make() has been called, otherwise FALSE.
   */
  protected $made = FALSE;

  /**
   * TRUE if download() method has been called successfully, otherwise FALSE.
   */
  protected $downloaded = NULL;

  /**
   * Download location to use.
   */
  protected $download_location = NULL;

  /**
   * Keep track of instances.
   *
   * @see GitopsScanRepos::getInstance()
   */
  protected static $self = array();

  /**
   * Keeps track of projects being processed to prevent recursive conflicts.
   *
   * Simple array of machine names.
   *
   * @var array
   */
  protected $manifest = array();

  /**
   * Default to overwrite to allow recursive builds to process properly.
   *
   * TODO refactor this to be more selective. Ideally a merge would take place
   * instead of an overwrite.
   */
  protected $overwrite = TRUE;

  /**
   * Recursively process any makefiles found in downloaded projects.
   */
  protected $do_recursion = TRUE;

  /**
   *
   */
  protected $persist_repos_instance = NULL;

  /**
   *
   */
  protected $found_projects = array();

  /**
   * Set attributes and retrieve project information.
   */
  protected function __construct($project) {
    $project['base_contrib_destination'] = $project['contrib_destination'];
    foreach ($project as $key => $value) {
      $this->{$key} = $value;
    }
    if (!empty($this->options['working-copy'])) {
      $this->download['working-copy'] = TRUE;
    }
  }

  /**
   * Set the project array.
   *
   * @param array $project
   *   The project array retrieved from a make file.
   */
  protected function setProject($project) {
    $this->project = $project;
  }

  /**
   * [getFoundRepos description]
   * @return [type]
   */
  public function getFoundProjects() {
    return $this->found_projects;
  }

  /**
   * Get an instance for the type and project.
   *
   * @param string $type
   *   Type of project: core, library, module, profile, or translation.
   * @param array $project
   *   Project information.
   *
   * @return mixed
   *   An instance for the project or FALSE if invalid type.
   */
  public static function getInstance($type, $project, $persist_repos_instance) {
    if (!isset(self::$self[$type][$project['name']])) {
      $class = 'GitopsScanRepos_' . $type;
      self::$self[$type][$project['name']] = class_exists($class) ? new $class($project) : FALSE;
    }
    $instance = self::$self[$type][$project['name']];
    $instance->setProject($project);
    $instance->persist_repos_instance = $persist_repos_instance;
    return $instance;
  }

  /**
   * Set the manifest array.
   *
   * @param array $manifest
   *   An array of projects as generated by `make_projects`.
   */
  public function setManifest($manifest) {
    $this->manifest = $manifest;
  }

  /**
   * Generate the proper path for this project type.
   *
   * @param boolean $base
   *   Whether include the base part (tmp dir). Defaults to TRUE.
   */
  protected function generatePath($base = TRUE) {
    $path = array();
    if ($base) {
      $path[] = make_tmp();
      $path[] = '__build__';
    }
    if (!empty($this->contrib_destination)) {
      $path[] = $this->contrib_destination;
    }
    if (!empty($this->subdir)) {
      $path[] = $this->subdir;
    }
    return implode('/', $path);
  }

  /**
   * Determine the location to download project to.
   */
  function findDownloadLocation() {
    $this->path = $this->generatePath();
    $this->project_directory = !empty($this->directory_name) ? $this->directory_name : $this->name;
    $this->download_location = $this->path . '/' . $this->project_directory;
    // This directory shouldn't exist yet -- if it does, stop,
    // unless overwrite has been set to TRUE.
    if (is_dir($this->download_location) && !$this->overwrite) {
      drush_set_error('MAKE_DIRECTORY_EXISTS', dt('Directory not empty: !directory', array('!directory' => $this->download_location)));
      return FALSE;
    }
    elseif ($this->download['type'] === 'pm') {
      // pm-download will create the final contrib directory.
      drush_mkdir(dirname($this->download_location));
    }
    else {
      drush_mkdir($this->download_location);
    }
    return $this->download_location;
  }

  /**
   * Determine the location to download project to.
   *
   * @return string
   *   Path to the location of the project from the Drupal root.
   */
  function findLocation() {
    $this->local_path = $this->generatePath(FALSE);
    $this->project_directory = !empty($this->directory_name) ? $this->directory_name : $this->name;
    $this->location = $this->local_path . '/' . $this->project_directory;
    // This directory should exist -- if not, stop.
    if (!is_dir($this->location)) {
      drush_set_error(dt('Directory empty: !directory', array('!directory' => $this->location)));
      return FALSE;
    }
    return $this->location;
  }

  /**
   * Find the Drupal root.
   *
   * @return string
   *   Path to Drupal root.
   */
  function getRoot() {
    return drush_locate_root(drush_cwd());
  }

  /**
   *
   */
  function findRepos() {

    if ($this->download['type'] == 'git') {

      $download_location = $this->findDownloadLocation();

      $location = $this->getRoot() . '/' . $this->findLocation();

      $this->found_projects = array(
        'src' => $location,
        'dest' => $download_location,
        'project' => $this->project,
        'repo_exists' => FALSE,
      );

      if (is_dir($location . '/.git')) {

        $this->found_projects['repo_exists'] = TRUE;

      }

      $this->recurse($this->location, $this->name);

    }

  }

  /**
   * Recurse to process additional makefiles that may be found during
   * processing.
   */
  function recurse($path, $name) {

    $makefile = $path . '/' . $name . '.make';
    if (!file_exists($makefile)) {
      $makefile = $path . '/drupal-org.make';
      if (!file_exists($makefile)) {
        return TRUE;
      }
    }

    $info = make_parse_info_file($makefile);

    $info['parent'] = $path;

    $this->persist_repos_instance->findRepos($info);

  }

  /**
   * Remove the .git directory from a project.
   */
  function removeGitDirectory() {
    if (isset($this->download['type']) && $this->download['type'] == 'git' && file_exists($this->download_location . '/.git')) {
      drush_delete_dir($this->download_location . '/.git', TRUE);
    }
  }

  /**
   * Add a lock file.
   */
  function addLockfile($project_directory) {
    if (!empty($this->lock)) {
      file_put_contents($project_directory . '/.drush-lock-update', $this->lock);
    }
    return TRUE;
  }

  /**
   * Return the proper path for dependencies to be placed in.
   *
   * @return string
   *   The path that dependencies will be placed in.
   */
  protected function buildPath($directory) {
    $this->base_contrib_destination = $directory;
    return $this->base_contrib_destination;
  }

}

/**
 * For processing Drupal core projects.
 */
class GitopsScanRepos_Core extends GitopsScanRepos {
  /**
   * Override constructor for core to adjust project info.
   */
  protected function __construct(&$project) {
    parent::__construct($project);
    // subdir and contrib_destination are not allowed for core.
    $this->subdir = '';
    $this->contrib_destination = '';
  }

  /**
   * Determine the location to download project to.
   */
  function findDownloadLocation() {
    $this->path = $this->download_location = $this->generatePath();
    $this->project_directory = '';
    if (is_dir($this->download_location)) {
      drush_set_error('MAKE_DIRECTORY_EXISTS', dt('Directory not empty: !directory', array('!directory' => $this->download_location)));
      return FALSE;
    }
    elseif ($this->download['type'] === 'pm') {
      // pm-download will create the final __build__ directory, so nothing to do
      // here.
    }
    else {
      drush_mkdir($this->download_location);
    }
    return $this->download_location;
  }
}

/**
 * For processing libraries.
 */
class GitopsScanRepos_Library extends GitopsScanRepos {
  /**
   * Override constructor for libraries to properly set contrib destination.
   */
  protected function __construct(&$project) {
    parent::__construct($project);
    // Allow libraries to specify where they should live in the build path.
    if (isset($project['destination'])) {
      $project_path = $project['destination'];
    }
    else {
      $project_path = 'libraries';
    }
    if (!empty($this->parent)) {
      $this->buildPath($this->parent);
    }

    $this->contrib_destination = ($this->base_contrib_destination != '.' ? $this->base_contrib_destination . '/' : '') . $project_path;
  }

  /**
   * No recursion for libraries, sorry :-(
   */
  function recurse($path) {
    // Return TRUE so that processing continues in the make() method.
    return TRUE;
  }

  /**
   * No translations for libraries.
   */
  function getTranslations($download_location) {
    // Return TRUE so that processing continues in the make() method.
    return TRUE;
  }
}

/**
 * For processing modules.
 */
class GitopsScanRepos_Module extends GitopsScanRepos {
  /**
   * Override constructor for modules to properly set contrib destination.
   */
  protected function __construct(&$project) {
    parent::__construct($project);
    if (!empty($this->parent)) {
      $this->buildPath($this->parent);
    }
    $this->contrib_destination = ($this->base_contrib_destination != '.' ? $this->base_contrib_destination . '/' : '') . 'modules';
  }
}

/**
 * For processing installation profiles.
 */
class GitopsScanRepos_Profile extends GitopsScanRepos {
  /**
   * Override contructor for installation profiles to properly set contrib
   * destination.
   */
  protected function __construct(&$project) {
    parent::__construct($project);
    $this->contrib_destination = (!empty($this->destination) ? $this->destination : 'profiles');
  }

  /**
   * Find the build path.
   */
  protected function buildPath($directory) {
    return $this->generatePath(FALSE) . '/' . $directory;
  }
}

/**
 * For processing themes.
 */
class GitopsScanRepos_Theme extends GitopsScanRepos {
  /**
   * Override contructor for themes to properly set contrib destination.
   */
  protected function __construct(&$project) {
    parent::__construct($project);
    if (!empty($this->parent)) {
      $this->buildPath($this->parent);
    }
    $this->contrib_destination = ($this->base_contrib_destination != '.' ? $this->base_contrib_destination . '/' : '') . 'themes';
  }
}

/**
 * For processing translations.
 */
class GitopsScanRepos_Translation extends GitopsScanRepos {
  /**
   * Override constructor for translations to properly set contrib destination.
   */
  protected function __construct(&$project) {
    parent::__construct($project);
    switch ($project['core']) {
      case '5.x':
        // Don't think there's an automatic place we can put 5.x translations,
        // so we'll toss them in a translations directory in the Drupal root.
        $this->contrib_destination = ($this->base_contrib_destination != '.' ? $this->base_contrib_destination . '/' : '') . 'translations';
        break;

      default:
        $this->contrib_destination = '';
        break;
    }
  }
}
